{
    "source": {
        "path": "src/",
        "modules": {
            "main": {
                "path": "main.zn",
                "code": "//!\n//! The Curve Stableswap contract.\n//!\n\nmod constants;\nmod types;\nmod transaction;\n\nuse self::types::Address;\nuse self::types::Timestamp;\nuse self::types::Integer;\nuse self::types::Balances;\nuse self::transaction::Transaction;\nuse self::constants::N_COINS;\nuse self::constants::ZERO;\nuse self::constants::ZERO_TIME;\nuse self::constants::ONE;\n\ncontract Stableswap {\n    coins: [Address; N_COINS];\n    balances: Balances;\n    fee: Integer;\n    admin_fee: Integer;\n\n    owner: Address;\n    token: Address;\n\n    initial_A: Integer;\n    future_A: Integer;\n    initial_A_time: Timestamp;\n    future_A_time: Timestamp;\n\n    admin_actions_deadline: Timestamp;\n    transfer_ownership_deadline: Timestamp;\n    future_fee: Integer;\n    future_admin_fee: Integer;\n    future_owner: Address;\n\n    kill_deadline: Timestamp;\n    is_killed: bool;\n\n    ///\n    /// _coins: Addresses of ERC20 conracts of coins\n    /// _pool_token: Address of the token representing LP share\n    /// _A: Amplification coefficient multiplied by n * (n - 1)\n    /// _fee: Fee to charge for exchanges\n    ///\n    pub fn initialize(\n        mut self,\n        tx: Transaction,\n\n        _coins: [Address; N_COINS],\n        _pool_token: Address,\n        _A: Integer,\n        _fee: Integer,\n    ) {\n        for i in 0..N_COINS {\n            assert!(_coins[i] != constants::ZERO_ADDRESS, \"Coin address cannot be zero\");\n            self.balances[i] = ZERO;\n        }\n        self.coins = _coins;\n        self.initial_A = _A;\n        self.future_A = _A;\n        self.fee = _fee;\n        self.owner = tx.from;\n        self.kill_deadline = tx.block.timestamp + constants::KILL_DEADLINE_DT;\n        self.is_killed = false;\n        self.token = _pool_token;\n    }\n\n    pub fn get_A(self, tx: Transaction) -> Integer {\n        self.get_A_inner(tx)\n    }\n\n    ///\n    /// Returns portfolio virtual price (for calculating profit)\n    /// scaled up by 1e18.\n    ///\n    pub fn get_virtual_price(self, tx: Transaction) -> Integer {\n        let D: Integer = Self::get_D(self.get_xp(self.get_rates()), self.get_A(tx));\n\n        // D is in the units similar to DAI (e.g. converted to precision 1e18)\n        // When balanced, D = n * x_u - total virtual value of the portfolio\n\n        let token_supply: Integer = 1; // self.token.totalSupply()\n        D * constants::PRECISION / ONE\n    }\n\n    ///\n    /// Simplified method to calculate addition or reduction in token supply at\n    /// deposit or withdrawal without taking fees into account (but looking at\n    /// slippage).\n    /// Needed to prevent front-running, not for precise calculations!\n    ///\n    pub fn calc_token_amount(\n        self,\n        tx: Transaction,\n        amounts: Balances,\n        deposit: bool,\n    ) -> Integer {\n        let mut _balances: Balances = self.balances;\n        let rates: Balances = self.get_rates();\n        let amp: Integer = self.get_A_inner(tx);\n        let D0: Integer = Self::get_D_mem(rates, _balances, amp);\n\n        for i in 0..N_COINS {\n            if deposit {\n                _balances[i] += amounts[i];\n            } else {\n                _balances[i] -= amounts[i];\n            };\n        }\n\n        let D1: Integer = Self::get_D_mem(rates, _balances, amp);\n        let token_amount: Integer = 1; // self.token.totalSupply()\n        let diff: Integer = if deposit {\n            D1 - D0\n        } else {\n            D0 - D1\n        };\n        diff * token_amount / D0\n    }\n\n    // @nonreentrant('lock')\n    pub fn add_liquidity(\n        mut self,\n        tx: Transaction,\n        amounts: Balances,\n        min_mint_amount: Integer,\n    ) {\n        // Amounts is amounts of c-tokens\n        assert!(!self.is_killed);\n\n        let use_landing: [bool; N_COINS] = constants::USE_LENDING;\n        let mut fees: Balances = constants::ZEROS;\n        let _fee: Integer = self.fee * (N_COINS / (4 * (N_COINS - 1))) as Integer;\n        let _admin_fee: Integer = self.admin_fee;\n        let amp: Integer = self.get_A_inner(tx);\n\n        let token_supply: Integer = 1; // self.token.totalSupply();\n        let rates: Balances = self.get_rates();\n\n        // Initial invariant\n        let mut D0: Integer = ZERO;\n        let old_balances: Balances = self.balances;\n        if token_supply > ZERO {\n            D0 = Self::get_D_mem(rates, old_balances, amp);\n        };\n\n        let mut new_balances: Balances = old_balances;\n        for i in 0..N_COINS {\n            if token_supply == ZERO {\n                assert!(amounts[i] > ZERO);\n            };\n            // balances store amounts of c-tokens\n            new_balances[i] = old_balances[i] + amounts[i];\n        }\n\n        // Invariant after change\n        let D1: Integer = Self::get_D_mem(rates, new_balances, amp);\n        assert!(D1 > D0);\n\n        // We need to recalculate the invariant accounting for fees\n        // to calculate fair user's share\n        let mut D2: Integer = D1;\n        if token_supply > ZERO {\n            // Only account for fees if we are not the first to deposit\n            for i in 0..N_COINS {\n                let ideal_balance: Integer = D1 * old_balances[i] / D0;\n                let difference: Integer = if ideal_balance > new_balances[i] {\n                    ideal_balance - new_balances[i]\n                } else {\n                    new_balances[i] - ideal_balance\n                };\n                fees[i] = _fee * difference / constants::FEE_DENOMINATOR;\n                self.balances[i] = new_balances[i] - (fees[i] * _admin_fee / constants::FEE_DENOMINATOR);\n                new_balances[i] -= fees[i];\n            }\n\n            D2 = Self::get_D_mem(rates, new_balances, amp);\n        } else {\n            self.balances = new_balances;\n        };\n\n        // Calculate, how much pool tokens to mint\n        let mint_amount: Integer = if token_supply == ZERO {\n            D1\n        } else {\n            token_supply * (D2 - D0) / D0\n        };\n\n        assert!(mint_amount >= min_mint_amount, \"Slippage screwed you\");\n\n        // Take coins from the sender\n//        for i in 0..N_COINS {\n//            if amounts[i] > 0 {\n//               assert_modifiable(\n//                    cERC20(self.coins[i]).transferFrom(msg.sender, self, amounts[i]))\n//            }\n//        }\n//\n//        self.token.mint(tx.from, mint_amount);\n//\n//        log.AddLiquidity(msg.sender, amounts, fees, D1, token_supply + mint_amount)\n    }\n\n    pub fn get_dy(self, tx: Transaction, i: i128, j: i128, dx: Integer) -> Integer {\n        // dx and dy in c-units\n\n        let rates: Balances = self.get_rates();\n        let xp: Balances = self.get_xp(rates);\n\n        let x: Integer = xp[i] + (dx * rates[i] / constants::PRECISION);\n        let y: Integer = self.get_y(tx, i, j, x, xp);\n        let dy: Integer = (xp[j] - y - ONE) * constants::PRECISION / rates[j];\n        let _fee: Integer = self.fee * dy / constants::FEE_DENOMINATOR;\n\n        dy - _fee\n    }\n\n    pub fn get_dy_underlying(self, tx: Transaction, i: i128, j: i128, dx: Integer) -> Integer {\n        // dx and dy in underlying units\n\n        let rates: Balances = self.get_rates();\n        let xp: Balances = self.get_xp(rates);\n        let precisions: Balances = constants::PRECISION_MUL;\n\n        let x: Integer = xp[i] + dx * precisions[i];\n        let y: Integer = self.get_y(tx, i, j, x, xp);\n        let dy: Integer = (xp[j] - y - ONE) / precisions[j];\n        let _fee: Integer = self.fee * dy / constants::FEE_DENOMINATOR;\n\n        dy - _fee\n    }\n\n    pub fn exchange(self, tx: Transaction, i: i128, j: i128, dx: Integer, min_dy: Integer) {\n        let rates: Balances = self.get_rates();\n        let dy: Integer = self.exchange_inner(tx, i, j, dx, rates);\n        assert!(dy >= min_dy, \"Exchange resulted in fewer coins than expected\");\n        let use_lending: [bool; N_COINS] = constants::USE_LENDING;\n\n//        assert_modifiable(cERC20(self.coins[i]).transferFrom(msg.sender, self, dx))\n//        assert_modifiable(cERC20(self.coins[j]).transfer(msg.sender, dy))\n//\n//        log.TokenExchange(msg.sender, i, dx, j, dy)\n    }\n\n    pub fn remove_liquidity(mut self, _amount: Integer, min_amounts: Balances) {\n        let total_supply: Integer = ZERO; // self.token.totalSupply()\n        let mut amounts: Balances = constants::ZEROS;\n        let fees: Balances = constants::ZEROS;\n        let use_lending: [bool; N_COINS] = constants::USE_LENDING;\n\n        for i in 0..N_COINS {\n            let value: Integer = self.balances[i] * _amount / total_supply;\n            assert!(value >= min_amounts[i], \"Withdrawal resulted in fewer coins than expected\");\n            self.balances[i] -= value;\n            amounts[i] -= value;\n        }\n\n//        self.token.burnFrom(msg.sender, _amount); // Will raise if not enough\n//\n//        log.RemoveLiquidity(msg.sender, amounts, fees, total_supply - _amount);\n    }\n\n    pub fn remove_liquidity_imbalance(mut self, tx: Transaction, amounts: Balances, max_burn_amount: Integer) {\n        assert!(!self.is_killed);\n        let use_lending: [bool; N_COINS] = constants::USE_LENDING;\n\n        let token_supply: Integer = ZERO; //self.token.totalSupply()\n        assert!(token_supply > ZERO);\n\n        let _fee: Integer = self.fee * (N_COINS / (4 * (N_COINS - 1))) as Integer;\n        let _admin_fee: Integer = self.admin_fee;\n        let rates: Balances = self.get_rates();\n        let amp: Integer = self.get_A_inner(tx);\n\n        let old_balances: Balances = self.balances;\n        let mut new_balances: Balances = old_balances;\n        let D0: Integer = Self::get_D_mem(rates, old_balances, amp);\n        for i in 0..N_COINS {\n            new_balances[i] -= amounts[i];\n        }\n        let D1: Integer = Self::get_D_mem(rates, new_balances, amp);\n        let mut fees: Balances = constants::ZEROS;\n        for i in 0..N_COINS {\n            let ideal_balance: Integer = D1 * old_balances[i] / D0;\n            let difference: Integer = if ideal_balance > new_balances[i] {\n                ideal_balance - new_balances[i]\n            } else {\n                new_balances[i] - ideal_balance\n            };\n            fees[i] = _fee * difference / constants::FEE_DENOMINATOR;\n            self.balances[i] = new_balances[i] - (fees[i] * _admin_fee / constants::FEE_DENOMINATOR);\n            new_balances[i] -= fees[i];\n        }\n        let D2: Integer = Self::get_D_mem(rates, new_balances, amp);\n\n        let token_amount: Integer = (D0 - D2) * token_supply / D0 + ONE;\n        assert!(token_amount < max_burn_amount, \"Slippage screwed you\");\n\n//        for i in 0..N_COINS {\n//            if amounts[i] > 0:\n//                assert_modifiable(cERC20(self.coins[i]).transfer(msg.sender, amounts[i]))\n//        }\n\n//        self.token.burnFrom(msg.sender, token_amount)  # Will raise if not enough\n//\n//        log.RemoveLiquidityImbalance(msg.sender, amounts, fees, D1, token_supply - token_amount)\n    }\n\n    pub fn remove_liquidity_one_coin(mut self, tx: Transaction, _token_amount: Integer, i: i128, min_amount: Integer) {\n        let mut dy: Integer = ZERO;\n        let mut dy_fee: Integer = ZERO;\n        let rates: Balances = self.get_rates();\n\n        let result = self.calc_withdraw_one_coin_inner(tx, _token_amount, i, rates);\n        dy = result.0;\n        dy_fee = result.1;\n        assert!(dy >= min_amount, \"Not enough coins removed\");\n\n        self.balances[i] -= (dy + dy_fee * self.admin_fee / constants::FEE_DENOMINATOR);\n//        self.token.burnFrom(msg.sender, _token_amount)\n//        assert_modifiable(ERC20(self.coins[i]).transfer(msg.sender, dy))\n//\n//        log.RemoveLiquidityOne(msg.sender, _token_amount, dy)\n    }\n\n    pub fn calc_withdraw_one_coin(self, tx: Transaction, _token_amount: Integer, i: i128) -> Integer {\n        let rates: Balances = self.get_rates();\n        self.calc_withdraw_one_coin_inner(tx, _token_amount, i, rates).0\n    }\n\n    fn exchange_inner(mut self, tx: Transaction, i: i128, j: i128, dx: Integer, rates: Balances) -> Integer {\n        assert!(!self.is_killed);\n        // dx and dy are in c-tokens\n\n        let old_balances: Balances = self.balances;\n        let xp: Balances = Self::get_xp_mem(rates, old_balances);\n\n        let x: Integer = xp[i] + dx * rates[i] / constants::PRECISION;\n        let y: Integer = self.get_y(tx, i, j, x, xp);\n\n        let mut dy: Integer = xp[j] - y - ONE; // -1 just in case there were some rounding errors\n        let dy_fee: Integer = dy * self.fee / constants::FEE_DENOMINATOR;\n        let mut dy_admin_fee: Integer = dy_fee * self.admin_fee / constants::FEE_DENOMINATOR;\n\n        // Convert all to real units\n        dy -= dy_fee;\n        dy *= constants::PRECISION / rates[j];\n        dy_admin_fee *= constants::PRECISION / rates[j];\n\n        // Change balances exactly in same way as we change actual ERC20 coin amounts\n        self.balances[i] = old_balances[i] + dx;\n        // When rounding errors happen, we undercharge admin fee in favor of LP\n        self.balances[j] = old_balances[j] - dy - dy_admin_fee;\n\n        dy\n    }\n\n    ///\n    /// Handle ramping A up or down.\n    ///\n    fn get_A_inner(\n        self,\n        tx: Transaction,\n    ) -> Integer {\n        let t1: Timestamp = self.future_A_time;\n        let A1: Integer = self.future_A;\n\n        if tx.block.timestamp < t1 {\n            let A0: Integer = self.initial_A;\n            let t0: Timestamp = self.initial_A_time;\n\n            // Expressions in Integer type cannot have negative numbers, thus:\n            if A1 > A0 {\n                A0 + (A1 - A0) * ((tx.block.timestamp - t0) / (t1 - t0)) as Integer\n            } else {\n                A0 - (A0 - A1) * ((tx.block.timestamp - t0) / (t1 - t0)) as Integer\n            }\n        } else {\n            A1\n        }\n    }\n\n    fn get_rates(self) -> Balances {\n        let mut result: Balances = constants::PRECISION_MUL;\n        let use_lending: [bool; N_COINS] = constants::USE_LENDING;\n        for i in 0..N_COINS {\n            // Used with no lending\n            let mut rate: Integer = constants::LENDING_PRECISION;\n//            if use_lending[i] {\n//                rate = cERC20(self.coins[i]).exchangeRateCurrent();\n//            }\n            result[i] *= rate;\n        }\n        result\n    }\n\n    fn get_xp(\n        self,\n        rates: Balances,\n    ) -> Balances {\n        let mut result: Balances = rates;\n        for i in 0..N_COINS {\n            result[i] *= self.balances[i] * constants::LENDING_PRECISION;\n        }\n        result\n    }\n\n    fn get_xp_mem(\n        rates: Balances,\n        _balances: Balances,\n    ) -> Balances {\n        let mut result: Balances = rates;\n        for i in 0..N_COINS {\n            result[i] *= _balances[i] * constants::LENDING_PRECISION;\n        }\n        result\n    }\n\n    pub fn get_D(xp: Balances, amp: Integer) -> Integer {\n        dbg!(\"{} {}\", xp, amp);\n\n        let mut S: Integer = ZERO;\n\n        for i in 0..N_COINS {\n            S += xp[i];\n        }\n\n        if S == ZERO {\n            ZERO\n        } else {\n            let mut Dprev: Integer = ZERO;\n            let mut D: Integer = S;\n            let Ann: Integer = amp * (N_COINS as Integer);\n\n            // Equality with the precision of 1\n            for _n in 0..4 while D - Dprev > ONE && Dprev - D > ONE {\n                let mut D_P: Integer = D;\n                for i in 0..N_COINS {\n                    // If division by 0, this will be borked: only withdrawal will work. And that is good\n                    D_P *= D / (xp[i] * (N_COINS as Integer));\n                    Dprev = D;\n                    D = (Ann * S + D_P * (N_COINS as Integer)) * D / ((Ann - ONE) * D + ((N_COINS + 1) as Integer) * D_P);\n                }\n            }\n\n            D\n        }\n    }\n\n    fn get_D_mem(rates: Balances, _balances: Balances, amp: Integer) -> Integer {\n        Self::get_D(Self::get_xp_mem(rates, _balances), amp)\n    }\n\n    fn get_y(self, tx: Transaction, i: i128, j: i128, x: Integer, _xp: Balances) -> Integer {\n        // x in the input is converted to the same price/precision\n\n        assert!(i != j && i >= 0 as i128 && j >= 0 as i128 && i < N_COINS as i128 && j < N_COINS as i128);\n\n        let amp: Integer = self.get_A_inner(tx);\n        let D: Integer = Self::get_D(_xp, amp);\n        let mut c: Integer = D;\n        let mut S_: Integer = ZERO;\n        let Ann: Integer = amp * (N_COINS as Integer);\n\n        let mut _x: Integer = ZERO;\n        for _i in 0..N_COINS {\n            let to_update = if _i as i128 == i {\n                _x = x;\n                true\n            } else if _i as i128 != j {\n                _x = _xp[_i];\n                true\n            } else {\n                false\n            };\n\n            if to_update {\n                S_ += _x;\n                c *= D / (_x * (N_COINS as Integer));\n            }\n        }\n        c *= D / (_x * (N_COINS as Integer));\n\n        let b: Integer = S_ + D / Ann; // - D\n        let mut y_prev: Integer = ZERO;\n        let mut y: Integer = D;\n        for _i in 0..255 while (y > y_prev && y - y_prev > ONE) || (y_prev <= y && y_prev - y > ONE) {\n            y_prev = y;\n            y = (y * y + c) / ((2 as Integer) * y + b - D);\n        }\n\n        y\n    }\n\n    ///\n    /// Calculate x[i] if one reduces D from being calculated for xp to D\n\n    /// Done by solving quadratic equation iteratively.\n    /// x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n    /// x_1**2 + b*x_1 = c\n\n    /// x_1 = (x_1**2 + c) / (2*x_1 + b)\n    ///\n    fn get_y_D(A: Integer, i: i128, xp: Balances, D: Integer) -> Integer {\n        // x in the input is converted to the same price/precision\n\n        assert!(i >= 0 as i128 && i < N_COINS as i128);\n\n        let mut c: Integer = D;\n        let mut S_: Integer = ZERO;\n        let Ann: Integer = A * N_COINS as Integer;\n\n        let mut _x: Integer = ZERO;\n        for _i in 0..N_COINS {\n            let to_update = if _i as i128 == i {\n                _x = xp[_i];\n                true\n            } else {\n                false\n            };\n\n            if to_update {\n                S_ += _x;\n                c *= D / (_x * (N_COINS as Integer));\n            }\n        }\n        c *= D / (_x * (N_COINS as Integer));\n\n        let b: Integer = S_ + D / Ann; // - D\n        let mut y_prev: Integer = ZERO;\n        let mut y: Integer = D;\n        for _i in 0..255 while (y > y_prev && y - y_prev > ONE) || (y_prev <= y && y_prev - y > ONE) {\n            y_prev = y;\n            y = (y * y + c) / ((2 as Integer) * y + b - D);\n        }\n\n        y\n    }\n\n    fn calc_withdraw_one_coin_inner(self, tx: Transaction, _token_amount: Integer, i: i128, rates: Balances) -> (Integer, Integer) {\n        // First, need to calculate\n        // * Get current D\n        // * Solve Eqn against y_i for D - _token_amount\n\n        let amp: Integer = self.get_A_inner(tx);\n        let _fee: Integer = self.fee * (N_COINS / (4 * (N_COINS - 1))) as Integer;\n        let precisions: Balances = constants::PRECISION_MUL;\n        let total_supply: Integer = ZERO; // self.token.totalSupply()\n\n        let xp: Balances = self.get_xp(rates);\n\n        let D0: Integer = Self::get_D(xp, amp);\n        let D1: Integer = D0 - _token_amount * D0 / total_supply;\n        let mut xp_reduced: Balances = xp;\n\n        let new_y: Integer = Self::get_y_D(amp, i, xp, D1);\n        let dy_0: Integer = (xp[i] - new_y) / precisions[i]; // w/o fees\n\n        for j in 0..N_COINS {\n            let dx_expected: Integer = if j as i128 == i {\n                xp[j] * D1 / D0 - new_y\n            } else {\n                xp[j] - xp[j] * D1 / D0\n            };\n            xp_reduced[j] -= _fee * dx_expected / constants::FEE_DENOMINATOR;\n        }\n\n        let mut dy: Integer = xp_reduced[i] - Self::get_y_D(amp, i, xp_reduced, D1);\n        dy = (dy - ONE) / precisions[i];\n\n        (dy, dy_0 - dy)\n    }\n\n    // Admin functions\n\n    pub fn ramp_A(mut self, tx: Transaction, _future_A: Integer, _future_time: Timestamp) {\n        assert!(tx.from == self.owner);\n        assert!(tx.block.timestamp >= self.initial_A_time + constants::MIN_RAMP_TIME);\n        assert!(_future_time >= tx.block.timestamp + constants::MIN_RAMP_TIME);\n\n        let _initial_A: Integer = self.get_A_inner(tx);\n        assert!(_future_A > ZERO && _future_A < constants::MAX_A);\n        assert!((_future_A >= _initial_A && _future_A <= _initial_A * constants::MAX_A_CHANGE) || (_future_A < _initial_A && _future_A * constants::MAX_A_CHANGE >= _initial_A));\n\n        self.initial_A = _initial_A;\n        self.future_A = _future_A;\n        self.initial_A_time = tx.block.timestamp;\n        self.future_A_time = _future_time;\n\n//        log.RampA(_initial_A, _future_A, block.timestamp, _future_time)\n    }\n\n    pub fn stop_ramp_A(mut self, tx: Transaction) {\n        assert!(tx.from == self.owner);\n\n        let current_A: Integer = self.get_A_inner(tx);\n        self.initial_A = current_A;\n        self.future_A = current_A;\n        self.initial_A_time = tx.block.timestamp;\n        self.future_A_time = tx.block.timestamp;\n\n        // now (block.timestamp < t1) is always False, so we return saved A\n\n//        log.StopRampA(current_A, block.timestamp)\n    }\n\n    pub fn commit_new_fee(mut self, tx: Transaction, new_fee: Integer, new_admin_fee: Integer) {\n        assert!(tx.from == self.owner);\n        assert!(self.admin_actions_deadline == ZERO_TIME);\n        assert!(new_admin_fee <= constants::MAX_ADMIN_FEE);\n        assert!(new_fee <= constants::MAX_FEE);\n\n        let _deadline: Timestamp = tx.block.timestamp + constants::ADMIN_ACTIONS_DELAY;\n        self.admin_actions_deadline = _deadline;\n        self.future_fee = new_fee;\n        self.future_admin_fee = new_admin_fee;\n\n//        log.CommitNewFee(_deadline, new_fee, new_admin_fee)\n    }\n\n    pub fn apply_new_fee(mut self, tx: Transaction) {\n        assert!(tx.from == self.owner);\n        assert!(self.admin_actions_deadline <= tx.block.timestamp && self.admin_actions_deadline > ZERO_TIME);\n\n        self.admin_actions_deadline = ZERO_TIME;\n        let _fee: Integer = self.future_fee;\n        let _admin_fee: Integer = self.future_admin_fee;\n        self.fee = _fee;\n        self.admin_fee = _admin_fee;\n\n//        log.NewFee(_fee, _admin_fee)\n    }\n\n    pub fn revert_new_parameters(mut self, tx: Transaction) {\n        assert!(tx.from == self.owner);\n\n        self.admin_actions_deadline = ZERO_TIME;\n    }\n\n    pub fn commit_transfer_ownership(mut self, tx: Transaction, _owner: Address) {\n        assert!(tx.from == self.owner);\n        assert!(self.transfer_ownership_deadline == ZERO_TIME);\n\n        let _deadline: Timestamp = tx.block.timestamp + constants::ADMIN_ACTIONS_DELAY;\n        self.transfer_ownership_deadline = _deadline;\n        self.future_owner = _owner;\n\n//        log.CommitNewAdmin(_deadline, _owner)\n    }\n\n    pub fn apply_transfer_ownership(mut self, tx: Transaction) {\n        assert!(tx.from == self.owner);\n        assert!(tx.block.timestamp >= self.transfer_ownership_deadline && self.transfer_ownership_deadline > ZERO_TIME);\n\n        self.transfer_ownership_deadline = ZERO_TIME;\n        let _owner: Address = self.future_owner;\n        self.owner = _owner;\n\n//        log.NewAdmin(_owner)\n    }\n\n    pub fn revert_transfer_ownership(mut self, tx: Transaction) {\n        assert!(tx.from == self.owner);\n\n        self.transfer_ownership_deadline = ZERO_TIME;\n    }\n\n    pub fn withdraw_admin_fees(mut self, tx: Transaction) {\n        assert!(tx.from == self.owner);\n\n//        for i in 0..N_COINS {\n//            let c: Address = self.coins[i];\n//            let value: Integer = cERC20(c).balanceOf(self) - self.balances[i];\n//            if value > 0 {\n//                assert_modifiable(cERC20(c).transfer(msg.sender, value))\n//            }\n//        }\n    }\n\n    pub fn kill_me(mut self, tx: Transaction) {\n        assert!(tx.from == self.owner);\n        assert!(self.kill_deadline > tx.block.timestamp);\n\n        self.is_killed = true;\n    }\n\n    pub fn unkill_me(mut self, tx: Transaction) {\n        assert!(tx.from == self.owner);\n\n        self.is_killed = false;\n    }\n}\n"
            },
            "constants": {
                "path": "constants.zn",
                "code": "//!\n//! The Curve Stableswap constants.\n//!\n\nuse crate::types::Integer;\nuse crate::types::Address;\nuse crate::types::Timestamp;\n\nconst N_COINS: u8 = 2;\n\nconst ZERO: Integer = 0;\nconst ZERO_TIME: Timestamp = 0;\nconst ZERO_ADDRESS: Address = 0;\nconst ONE: Integer = 1;\nconst ZEROS: [Integer; N_COINS] = [0 as Integer; N_COINS];\n\nconst USE_LENDING: [bool; N_COINS] = [false; N_COINS];\n\nconst FEE_DENOMINATOR: Integer = 10_000_000_000;\nconst LENDING_PRECISION: Integer = 1_000_000_000_000_000_000;\nconst PRECISION: Integer = 1_000_000_000_000_000_000;\nconst PRECISION_MUL: [Integer; N_COINS] = [\n    PRECISION / PRECISION, // DAI\n    PRECISION / 1_000_000 as Integer, // USDC\n];\n\nconst ADMIN_ACTIONS_DELAY: Timestamp = (86400 as Timestamp) * (3 as Timestamp);\nconst MIN_RAMP_TIME: Timestamp = 86400;\n\nconst MAX_ADMIN_FEE: Integer = 5_000_000_000;\nconst MAX_FEE: Integer = 5_000_000_000;\nconst MAX_A: Integer = 1_000_000;\nconst MAX_A_CHANGE: Integer = 10;\n\nconst KILL_DEADLINE_DT: Timestamp = (86400 as Timestamp) * (30 * 2) as Timestamp;\n"
            },
            "types": {
                "path": "types.zn",
                "code": "//!\n//! The Curve Stableswap types.\n//!\n\ntype Address = u160;\ntype Timestamp = u64;\ntype Integer = u248;\ntype Hash = [bool; 256];\ntype Balances = [Integer; crate::constants::N_COINS];\n"
            },
            "transaction": {
                "path": "transaction.zn",
                "code": "//!\n//! The contract transaction.\n//!\n\nuse crate::types::Address;\nuse crate::types::Integer;\nuse crate::types::Timestamp;\nuse crate::types::Hash;\n\nstruct Block {\n    timestamp: Timestamp,\n}\n\nstruct Transaction {\n    from: Address,\n    to: Address,\n    token: u64,\n    value: Integer,\n    fee: Integer,\n    nonce: field,\n\n    block: Block,\n\n    data_hash: Hash,\n    witness_hash: Hash,\n}\n"
            }
        }        
    }
}
