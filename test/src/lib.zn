//
// Merkle tree library
//

use std::crypto;

type Digest = [bool; 256];

fn balance_hash(balance: field) -> Digest {
    let bits = std::convert::to_bits(balance);
    let bits_padded = std::array::pad(bits, 256, false);
    crypto::sha256(bits_padded)
}

fn merkle_node_hash(left: Digest, right: Digest) -> Digest {
    let v = [false; 256];
    v

    // let mut data = [false; 512];

    // for i in 0 as u16..256 {
    //     data[i] = left[i];
    //     data[256 + i] = right[i];
    // }

    // crypto::sha256(data)
}

fn restore_root_hash(
    leaf_hash: Digest,
    address: [bool; 1],
    merkle_path: [Digest; 1],
) -> Digest
{
    let mut current = leaf_hash;

    for i in 0..1 {
        let left_and_right = if address[i] {
            [current, merkle_path[i]]
        } else {
            [merkle_path[i], current]
        };

        current = merkle_node_hash(left_and_right[0], left_and_right[1]);
    }

    current
}
