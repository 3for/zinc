//!
//! The Curve Stableswap contract.
//!
//! Rewritten from [Vyper implementation](https://github.com/curvefi/curve-contract/blob/2b8ff42f5ce648be749c721d23c28ec8483df493/vyper/stableswap.vy)
//!
//! The [Curve Stableswap paper](https://www.curve.fi/stableswap-paper.pdf)
//!

mod types;

use std::assets::Token;

use self::types::Address;
use self::types::Balance;
use self::types::TokenId;
use self::types::Transaction;

/// A frequently used constant.
const ZERO: Balance = 0;
/// A frequently used constant.
const ONE: Balance = 1;

/// The default calculation precision.
const PRECISION: Balance = 1_000_000_000_000_000_000;

/// The number of tokens the contract can work with.
/// `N` cannot be more than 2 as long as Zinc does not support witness array indexing.
const N: u8 = 2;

///
/// The Curve Stableswap contract.
///
contract Stableswap {
    /// The contract address.
    address: Address;
    /// The contract balances.
    balances: [Balance; 2];
    /// The Curve amplifier.
    A: u64;

    ///
    /// The contract constructor.
    ///
    pub fn new(
        _address: Address,
        _A: u64,
    ) -> Self {
        Self {
            address: _address,
            balances: [ZERO; N],
            A: _A,
        }
    }

    ///
    /// Deposits a pair of token amounts to the contract balance.
    ///
    pub fn deposit(
        mut self,
        amounts: [Balance; 2],
    ) {
        // Invariant before change
        let D0: Balance = self.get_D(self.balances);

        for i in 0..N {
            self.balances[i] += amounts[i];
        }

        // Invariant after change
        let D1 = self.get_D(self.balances);
        assert!(D1 > D0, "Nothing has been deposited");
    }

    ///
    /// The exchange function.
    ///
    pub fn swap(
        mut self,
        tx: Transaction,
        min_withdraw: Balance,
    ) {
        let old_y = self.get_withdraw(tx.token_id);

        let new_x = self.get_deposit(tx.token_id) + tx.amount;
        let new_y = self.get_y(new_x);

        assert!(old_y >= min_withdraw + new_y, "Exchange resulted in fewer coins than expected");
        let withdrawn = old_y - new_y;

        self.set_deposit(tx.token_id, new_x);
        self.set_withdraw(tx.token_id, new_y);

        std::assets::Token::transfer(tx.from, self.address, tx.token_id, tx.amount, 1 as Balance);
        std::assets::Token::transfer(self.address, tx.to, tx.token_id.opposite(), withdrawn, 1 as Balance);
    }

    ///
    /// The `D` invariant.
    ///
    fn get_D(
        self,
        _balances: [Balance; 2],
    ) -> Balance {
        let mut S = ZERO;
        for i in 0..N {
            S += _balances[i];
        }

        let An: Balance = self.A * (N as u64);

        if S != ZERO {
            let mut D = S;

            for _n in 0..255 {
                let mut D_P = D;
                for i in 0..N {
                    if _balances[i] > 0 {
                        D_P *= D / (_balances[i] * (N as Balance));
                    }
                }
                D = (An * S + D_P * (N as Balance)) * D / ((An - ONE) * D + ((N + 1) as Balance) * D_P);
            }

            D
        } else {
            ZERO
        }
    }

    ///
    /// The amount user gets after the swap.
    ///
    fn get_y(self, x: Balance) -> Balance {
        let D = self.get_D(self.balances) * PRECISION;
        let c = D * D / (x * (N as Balance));
        let An: Balance = self.A * (N as u64);
        let b: Balance = x * PRECISION + D / An;

        let mut y: Balance = D;
        for _i in 0..255 {
            y = (y * y + c) / (2 * y + b - D);
        }

        y / PRECISION
    }

    ///
    /// The token being deposited balance setter.
    ///
    fn set_deposit(mut self, token_id: TokenId, amount: Balance) {
        match token_id {
            TokenId::First => self.balances[0] = amount,
            TokenId::Second => self.balances[1] = amount,
        }
    }

    ///
    /// The token being withdrawn balance setter.
    ///
    fn set_withdraw(mut self, token_id: TokenId, amount: Balance) {
        match token_id {
            TokenId::First => self.balances[1] = amount,
            TokenId::Second => self.balances[0] = amount,
        }
    }

    ///
    /// The token being deposited balance getter.
    ///
    fn get_deposit(self, token_id: TokenId) -> Balance {
        match token_id {
            TokenId::First => self.balances[0],
            TokenId::Second => self.balances[1],
        }
    }

    ///
    /// The token being withdrawn balance getter.
    ///
    fn get_withdraw(self, token_id: TokenId) -> Balance {
        match token_id {
            TokenId::First => self.balances[1],
            TokenId::Second => self.balances[0],
        }
    }
}
