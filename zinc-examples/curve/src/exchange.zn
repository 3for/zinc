//!
//! The swap consequences calculation.
//!

use crate::types::Balance;
use crate::types::token_id::TokenId;
use crate::constants::ZERO;
use crate::constants::PRECISION;
use crate::constants::N;

///
/// The amount user gets after the swap.
///
fn after(
    amplifier: u64,
    balances: [Balance; N],
    token_x_id: TokenId,
    token_y_id: TokenId,
    after_deposit: Balance,
) -> Balance {
    assert!(token_x_id != token_y_id, "Cannot exchange between the same coins");
    assert!(0 <= token_x_id as u8 && token_x_id as u8 < N, "The token X ID must be between 0 and 4");
    assert!(0 <= token_y_id as u8 && token_y_id as u8 < N, "The token Y ID must be between 0 and 4");

    let mut xp = balances;
    for i in 0..N {
        xp[i] *= PRECISION;
    }

    let D = crate::invariant::calculate(amplifier, xp);
    let An: Balance = amplifier * (N as u64);

    let mut c = D;
    let mut S: Balance = ZERO;

    for i in 0..N {
        if i == token_x_id as u8 {
            S += after_deposit * PRECISION;
            c = c * D / (after_deposit * PRECISION * (N as Balance));
        } else if i != token_y_id as u8 {
            S += xp[i];
            c = c * D / (xp[i] * (N as Balance));
        };
    }

    c = c * D / (An * (N as Balance));
    let b: Balance = S + D / An;

    let mut y_prev: Balance = ZERO;
    let mut y: Balance = D;
    for n in 0..255 while (y > y_prev && y - y_prev > ZERO) || (y <= y_prev && y_prev - y > ZERO) {
        y_prev = y;
        y = (y * y + c) / (2 * y + b - D);
    }

    y / PRECISION
}
