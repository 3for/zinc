//!
//! The invariant calculation.
//!

use crate::types::Balance;
use crate::constants::ZERO;
use crate::constants::N;

///
/// The `D` invariant calculation function.
///
pub fn calculate(
    amplifier: u64,
    values: [Balance; N],
) -> Balance {
    let mut sum = ZERO;
    for i in 0..N {
        sum += values[i];
    }

    if sum != ZERO {
        let mut D_prev = ZERO;
        let mut D = sum;

        let amplifier_N: Balance = amplifier * (N as u64);

        for _n in 0..255 while (D > D_prev && D - D_prev > 0) || (D <= D_prev && D_prev - D > ZERO) {
            let mut D_P = D;

            for i in 0..N {
                D_P = D_P * D / (values[i] * (N as Balance) + 1); // +1 is to prevent division by 0
            }

            D_prev = D;
            D = (amplifier_N * sum + D_P * (N as Balance)) * D / ((amplifier_N - 1) * D + ((N + 1) as Balance) * D_P);
        }

        D
    } else {
        ZERO
    }
}
